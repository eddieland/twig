//! Shared branch switching service API used by both the CLI and plugins.
//!
//! The goal of this module is to capture the behavioural contract of the
//! `twig switch` workflow so that alternative front-ends (for example the
//! `twig flow` plugin) can drive the same logic without duplicating git
//! plumbing or persistence code. The implementation will be filled in by a
//! later task; for now we provide a strongly-typed request/response model and
//! service skeleton.

use std::borrow::Cow;

use anyhow::Error as AnyError;
use git2::Repository;
use thiserror::Error;

use crate::git::BranchName;
use crate::state::RepoState;

/// High-level action requested from the switch service.
#[derive(Debug, Clone)]
pub enum BranchSwitchAction<'a> {
  /// Switch to the root of the current branch's dependency tree.
  DependencyRoot,
  /// Switch to a specific target resolved from user input.
  Target(BranchSwitchTarget<'a>),
}

/// Target that can be resolved into a concrete branch checkout.
#[derive(Debug, Clone)]
pub enum BranchSwitchTarget<'a> {
  /// Explicit branch name supplied by the caller.
  BranchName(Cow<'a, str>),
  /// Jira issue that should be mapped to a branch, optionally providing a name
  /// hint if the caller already derived one.
  JiraIssue {
    /// Normalised Jira issue key (e.g. `PROJ-123`).
    key: Cow<'a, str>,
    /// Optional branch name suggestion generated by the caller.
    branch_name_hint: Option<Cow<'a, str>>,
  },
  /// GitHub pull request reference that should be mapped to a branch.
  GitHubPullRequest {
    /// The pull request number within the repository.
    number: u32,
    /// Optional fully-qualified repository slug (`owner/repo`).
    repository: Option<Cow<'a, str>>,
    /// Optional branch name suggestion generated by the caller.
    branch_name_hint: Option<Cow<'a, str>>,
  },
}

/// Policy describing how branch creation should be handled.
#[derive(Debug, Clone)]
pub struct BranchCreationPolicy<'a> {
  /// Whether the service is allowed to create a branch when it does not exist.
  pub allow: bool,
  /// Desired parent branch selection when a new branch is created.
  pub parent: BranchParentSelection<'a>,
}

impl<'a> BranchCreationPolicy<'a> {
  /// Construct a new creation policy using the provided settings.
  pub fn new(allow: bool, parent: BranchParentSelection<'a>) -> Self {
    Self { allow, parent }
  }
}

impl<'a> Default for BranchCreationPolicy<'a> {
  fn default() -> Self {
    Self {
      allow: true,
      parent: BranchParentSelection::UseCurrent,
    }
  }
}

/// Strategy for selecting the parent branch during creation flows.
#[derive(Debug, Clone)]
pub enum BranchParentSelection<'a> {
  /// Use the currently checked-out branch as the base.
  UseCurrent,
  /// Use a specific branch name as the base.
  Explicit(Cow<'a, str>),
  /// Resolve the base from a Jira issue association.
  JiraIssue(Cow<'a, str>),
  /// Do not set any parent (for example when adopting repository default).
  None,
}

/// Controls how remote tracking relationships should be applied.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum TrackingPolicy {
  /// Maintain the existing behaviour of the CLI (`twig switch`) by attempting
  /// to attach to remote branches when appropriate.
  Inherit,
  /// Require the resulting branch to track a remote, surfacing an error if no
  /// remote is available.
  RequireTracking,
  /// Avoid creating or altering remote tracking configuration.
  NoTracking,
}

/// Request describing the desired branch switch operation.
#[derive(Debug, Clone)]
pub struct BranchSwitchRequest<'a> {
  /// The high-level action to perform.
  pub action: BranchSwitchAction<'a>,
  /// Policy covering branch creation and parent selection.
  pub creation: BranchCreationPolicy<'a>,
  /// Desired remote tracking behaviour.
  pub tracking: TrackingPolicy,
  /// When set, the service should report the outcome without performing any
  /// irreversible git operations.
  pub dry_run: bool,
}

impl<'a> BranchSwitchRequest<'a> {
  /// Build a new request for the provided action using default policies.
  pub fn new(action: BranchSwitchAction<'a>) -> Self {
    Self {
      action,
      creation: BranchCreationPolicy::default(),
      tracking: TrackingPolicy::Inherit,
      dry_run: false,
    }
  }

  /// Enable dry-run mode for the request.
  pub fn with_dry_run(mut self, dry_run: bool) -> Self {
    self.dry_run = dry_run;
    self
  }

  /// Override the creation policy for the request.
  pub fn with_creation_policy(mut self, policy: BranchCreationPolicy<'a>) -> Self {
    self.creation = policy;
    self
  }

  /// Override the tracking policy for the request.
  pub fn with_tracking_policy(mut self, policy: TrackingPolicy) -> Self {
    self.tracking = policy;
    self
  }
}

/// Result describing the mutations applied by the switch service.
#[derive(Debug, Clone)]
pub enum BranchSwitchOutcome {
  /// The repository was already on the desired branch.
  AlreadyOnBranch { branch: BranchName },
  /// Switched to an existing branch without creating new references.
  CheckedOut { branch: BranchName },
  /// Checked out a remote tracking branch and configured local tracking.
  CheckedOutRemote {
    /// Local branch that now tracks the remote.
    branch: BranchName,
    /// Information about the remote assignment.
    remote: RemoteTrackingAssignment,
  },
  /// Created a new branch and checked it out.
  Created {
    /// Newly created branch name.
    branch: BranchName,
    /// Optional parent branch used as the creation base.
    parent: Option<BranchName>,
    /// Remote tracking configuration applied after creation.
    remote: Option<RemoteTrackingAssignment>,
  },
  /// No changes were required (for example in dry-run mode).
  NoChanges,
}

/// Details about remote tracking configuration applied to a branch.
#[derive(Debug, Clone)]
pub struct RemoteTrackingAssignment {
  /// Remote branch reference (e.g. `origin/main`).
  pub remote_branch: BranchName,
  /// Remote name component (e.g. `origin`).
  pub remote_name: String,
}

/// Errors that can occur when executing a branch switch request.
#[derive(Debug, Error)]
pub enum BranchSwitchError {
  /// Placeholder variant used while the service implementation is under
  /// construction.
  #[error("branch switch service has not been implemented yet")]
  NotImplemented,
  /// The requested target could not be resolved to a concrete branch.
  #[error("failed to resolve target branch for the requested input")]
  UnresolvedTarget,
  /// Branch creation was disabled but no existing branch matched the request.
  #[error("branch does not exist and creation was not permitted")]
  CreationNotAllowed,
  /// Wrapper for git-level errors encountered during execution.
  #[error(transparent)]
  Git(#[from] git2::Error),
  /// Wrapper for other error types that may bubble up.
  #[error(transparent)]
  Other(#[from] AnyError),
}

/// Builder used to configure and create a [`BranchSwitchService`].
pub struct BranchSwitchServiceBuilder<'repo> {
  repo: &'repo Repository,
  repo_state: &'repo mut RepoState,
}

impl<'repo> BranchSwitchServiceBuilder<'repo> {
  /// Create a new builder for the provided repository and state handle.
  pub fn new(repo: &'repo Repository, repo_state: &'repo mut RepoState) -> Self {
    Self { repo, repo_state }
  }

  /// Finalise builder configuration and construct the service.
  pub fn build(self) -> BranchSwitchService<'repo> {
    BranchSwitchService {
      repo: self.repo,
      repo_state: self.repo_state,
    }
  }
}

/// Service responsible for coordinating branch switching operations.
pub struct BranchSwitchService<'repo> {
  repo: &'repo Repository,
  repo_state: &'repo mut RepoState,
}

impl<'repo> BranchSwitchService<'repo> {
  /// Execute a branch switch request.
  ///
  /// The concrete implementation is deferred to a future task; callers can
  /// begin integrating with the API today to ensure consistent behaviour
  /// between the CLI and plugin surfaces.
  pub fn execute(&mut self, request: &BranchSwitchRequest<'_>) -> Result<BranchSwitchOutcome, BranchSwitchError> {
    let _ = &self.repo;
    let _ = &self.repo_state;
    let _ = request;

    Err(BranchSwitchError::NotImplemented)
  }
}
